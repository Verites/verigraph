{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Data.TypedGraph.PartitionSpec where

import           Control.Monad
import           Math.Combinat.Numbers        (bellNumber)
import           Test.Hspec

import           Abstract.Category.NewClasses
import           Abstract.Rewriting.DPO
import           Analysis.CriticalPairs
import qualified Category.TypedGraph          as TGraph
import qualified Category.TypedGraphRule      as TGRule
import           Data.Graphs
import           Data.Graphs.Morphism
import           Data.TypedGraph
import           Data.TypedGraph.Morphism
import qualified XML.GGXReader                as XML

fileName1 = "tests/grammars/sndOrderEpi.ggx"
fileName2 = "tests/grammars/partialInjectivity.ggx"
dpoConf1 = TGRule.Config (TGraph.Config Data.Graphs.empty TGraph.MonicMatches) TGRule.MonicMatches
dpoConf2 = TGRule.Config (TGraph.Config Data.Graphs.empty TGraph.AllMatches) TGRule.MonicMatches
dpoConf3 = TGRule.Config (TGraph.Config Data.Graphs.empty TGraph.MonicMatches) TGRule.MonicMatches
dpoConf4 = TGRule.Config (TGraph.Config Data.Graphs.empty TGraph.AllMatches) TGRule.MonicMatches

spec :: Spec
spec = context "Partitions Test" partitionsTest

partitionsTest :: Spec
partitionsTest =
  describe "Partition generation algorithm" $ do
    it "Should generate the same elements number as the bell numbers" testPartition

    it "Number of produce-forbid conflicts" $ do
      (gg1a2,_,_) <- XML.readGrammar fileName2 False dpoConf1
      (gg1b2,_,_) <- XML.readGrammar fileName2 False dpoConf2
      (gg1c2,_,_) <- XML.readGrammar fileName2 False dpoConf3
      (gg1d2,_,_) <- XML.readGrammar fileName2 False dpoConf4

      testProduceForbid dpoConf1 gg1a2 18
      testProduceForbid dpoConf2 gg1b2 18
      testProduceForbid dpoConf3 gg1c2 18
      testProduceForbid dpoConf4 gg1d2 30

-- Tests the number of produce-forbid conflicts, it is linked to the
-- overlappings generated by CreateJointlyEpimorphicPairsFromNAC.
testProduceForbid conf gg n =
  do
    let rL = snd (head (productions gg))
        rR = snd (head (tail (productions gg)))
        proFor = TGraph.runCat (TGRule.fstOrderConfig conf) $ findAllProduceForbid rL rR

    length proFor `shouldBe` n

-- Tests if the partition generation algorithm generates all expected number of combinations
testPartition = do
  -- Tests if a graph with the same repeated node n times has partitions length equals to the n-th bell number
  forM_ ids $ \n ->
    length (quotientsOf $ graph1 [1..n]) `shouldBe` fromInteger (bellNumber n)
  -- Tests if a graph with the same repeated edge n times has partitions length equals to the n-th bell number
  forM_ ids $ \e ->
    length (quotientsOf $ graph2 [1..e]) `shouldBe` fromInteger (bellNumber e)

quotientsOf :: TypedGraph a b -> [TypedGraphMorphism a b]
quotientsOf = TGraph.runCat (TGRule.fstOrderConfig dpoConf1) . findAllQuotientsOf

limitBellNumber = 8
ids = [1..limitBellNumber]

--typegraph: graph with one node and one edge on itself
typegraph = insertEdge (EdgeId 0) (NodeId 0) (NodeId 0) (insertNode (NodeId 0) Data.Graphs.empty)

--graph1: typed graph with 'limitBellNumber' nodes of same type
initGraph1 = Data.Graphs.Morphism.empty Data.Graphs.empty typegraph
graph1 = foldr (\n -> Data.Graphs.Morphism.createNodeOnDomain (NodeId n) (NodeId 0)) initGraph1

--graph2: typed graph with 'limitBellNumber' edges of same type with the same source and target
initGraph2 = Data.Graphs.Morphism.empty (insertNode (NodeId 0) Data.Graphs.empty) typegraph
graph2 = foldr
           (\e -> Data.Graphs.Morphism.createEdgeOnDomain (EdgeId e) (NodeId 0) (NodeId 0) (EdgeId 0))
           (updateNodes (NodeId 0) (NodeId 0) initGraph2)
