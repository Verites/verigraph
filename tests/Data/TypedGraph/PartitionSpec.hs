{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

module Data.TypedGraph.PartitionSpec where

import           Math.Combinat.Numbers                 (bellNumber)
import           Test.Hspec

import           Abstract.Category
import           Abstract.Category.Finitary
import           Abstract.Rewriting.DPO
import           Analysis.CriticalPairs
import           Category.TypedGraphRule
import           Data.Graphs
import           Data.Graphs.Morphism
import           Data.TypedGraph.Morphism
import qualified XML.GGXReader                         as XML

fileName1 = "tests/grammars/sndOrderEpi.ggx"
fileName2 = "tests/grammars/partialInjectivity.ggx"
dpoConf1 = MorphismsConfig monic
dpoConf2 = MorphismsConfig anyMorphism

spec :: Spec
spec = context "Partitions Test" partitionsTest

partitionsTest :: Spec
partitionsTest =
  describe "Partition generation algorithm" $ do
    it "Should generate the same elements number as the bell numbers" testPartition

    it "Number of overlapping pairs generated by create epi from NAC" $ do
      (gg1a1,gg2a1,_) <- XML.readGrammar fileName1 False dpoConf1
      (gg1b1,gg2b1,_) <- XML.readGrammar fileName1 False dpoConf2

      testCreateJointlyEpimorphicPairsFromNAC dpoConf1 gg1a1 gg2a1 21
      testCreateJointlyEpimorphicPairsFromNAC dpoConf2 gg1b1 gg2b1 26

    it "Number of produce-forbid conflicts" $ do
      (gg1a2,_,_) <- XML.readGrammar fileName2 False dpoConf1
      (gg1b2,_,_) <- XML.readGrammar fileName2 False dpoConf2

      testProduceForbid dpoConf1 gg1a2 18
      testProduceForbid dpoConf2 gg1b2 18

-- Tests the number of produce-forbid conflicts, it is linked to the
-- overlappings generated by CreateJointlyEpimorphicPairsFromNAC.
testProduceForbid conf gg n =
  do
    let rL = snd (head (productions gg))
        rR = snd (head (tail (productions gg)))
        proFor = findAllProduceForbid conf rL rR

    length proFor `shouldBe` n

-- Tests the number of overlapping pairs generated by createJointlyEpimorphicPairsFromNAC
testCreateJointlyEpimorphicPairsFromNAC conf gg1 gg2 n =
  do
    let r1 = snd (head (productions gg1))
        r2 = snd (head (productions gg2))
        rr1 = r1 { nacs = [] }
        rr2 = head (nacs r2)
        epi = createJointlyEpimorphicPairsFromNAC conf (leftObject rr1) (mappingLeft rr2)

    length epi `shouldBe` n

-- Tests if the partition generation algorithm generates all expected number of combinations
testPartition =
  do
  -- Tests if a graph with the same repeated node n times has partitions length equals to the n-th bell number
  mapM_ (\n -> fromInteger (bellNumber n) `shouldBe` length (getPart (graph1 [1..n]))) ids
  -- Tests if a graph with the same repeated edge n times has partitions length equals to the n-th bell number
  mapM_ (\e -> fromInteger (bellNumber e) `shouldBe` length (getPart (graph2 [1..e]))) ids

getPart :: GraphMorphism (Maybe a) (Maybe b) -> [TypedGraphMorphism a b]
getPart = findAllQuotientsOf

limitBellNumber = 8
ids = [1..limitBellNumber]

--typegraph: graph with one node and one edge on itself
typegraph = insertEdge (EdgeId 0) (NodeId 0) (NodeId 0) (insertNode (NodeId 0) Data.Graphs.empty)

--graph1: typed graph with 'limitBellNumber' nodes of same type
initGraph1 = Data.Graphs.Morphism.empty Data.Graphs.empty typegraph
graph1 = foldr (\n -> Data.Graphs.Morphism.createNodeOnDomain (NodeId n) (NodeId 0)) initGraph1

--graph2: typed graph with 'limitBellNumber' edges of same type with the same source and target
initGraph2 = Data.Graphs.Morphism.empty (insertNode (NodeId 0) Data.Graphs.empty) typegraph
graph2 = foldr
           (\e -> Data.Graphs.Morphism.createEdgeOnDomain (EdgeId e) (NodeId 0) (NodeId 0) (EdgeId 0))
           (updateNodes (NodeId 0) (NodeId 0) initGraph2)
