{-# LANGUAGE FlexibleContexts #-}
module Analysis.ConcurrentRules
( CRDependencies (..),
  allConcurrentRules,
  maxConcurrentRule
) where

import           Abstract.Morphism
import           Abstract.AdhesiveHLR
import           Abstract.DPO
import           Analysis.CriticalSequence (criticalSequences,getM1,getM2)

data CRDependencies = AllOverlapings | OnlyDependency

{-Functions types ommited because ghc do not associates m with TypedGraphMorphism a b, still fix-}

-- | Generates the Concurrent Rules for a given list of GraphRules following the order of the elements in the list. If the first argument evaluates to True, it will calculate only rules generated by Injective EpiPairs
--allConcurrentRules :: (DPO m, EpiPairs m, Eq (Obj m)) => Bool -> Bool -> Bool -> [Production m] -> [Production m]
allConcurrentRules _ _ _ [] = []
allConcurrentRules _ _ _ [x] = [x]
allConcurrentRules dep nacInj injectiveOnly (x:xs) = concatMap (crs x) (allCRs xs)
  where
    crs = concurrentRules dep nacInj injectiveOnly
    allCRs = allConcurrentRules dep nacInj injectiveOnly

-- | Generates the Concurrent Rule with the least disjoint EpiPair for a given list of GraphRules (following the order of the elements in the list). If the first argument evaluates to True, it will generate only the least disjoint injective EpiPair
--maxConcurrentRule :: (DPO m, EpiPairs m, Eq (Obj m)) => Bool -> Bool -> [Production m] -> Production m
maxConcurrentRule dep nacInj injectiveOnly rules = last $ maxConcurrentRules dep nacInj injectiveOnly rules

--maxConcurrentRules :: (DPO m, EpiPairs m, Eq (Obj m)) => Bool -> Bool -> [Production m] -> [Production m]
maxConcurrentRules _ _ _ [] = []
maxConcurrentRules _ _ _ [x] = [x]
maxConcurrentRules dep nacInj injectiveOnly (x:xs) = map (singleCR x) (maxCRs xs)
  where
    singleCR = maxConcurrentRuleForLastPair dep nacInj injectiveOnly
    maxCRs = maxConcurrentRules dep nacInj injectiveOnly

--concurrentRules :: (DPO m, EpiPairs m, Eq (Obj m)) => Bool -> Bool -> Production m -> Production m -> [Production m]
concurrentRules dep nacInj isInjective c n = map (concurrentRuleForPair isInjective c n) selectedPairs
  where
    selectedPairs = case dep of
                      OnlyDependency -> dependencies
                      _ -> allPairs
    allPairs = pairs isInjective c n
    dependencies = depPairs nacInj isInjective c n

--depPairs :: (EpiPairs m, DPO m) => Bool -> Bool -> Production m -> Production m -> [(m, m)]
depPairs nacInj isInjective c n = map (\cs -> (getM1 cs, getM2 cs)) $ criticalSequences nacInj isInjective c n

pairs :: (EpiPairs m, DPO m) => Bool -> Production m -> Production m -> [(m, m)]
pairs isInjective c n = validDpoPairs
  where
    allPairs  = createPairsCodomain isInjective (right c) (left n)
    validDpoPairs = filter (\(lp, rp) -> satsGluing isInjective lp (inverseWithoutNacs c) && satsGluing isInjective rp n) allPairs

--maxConcurrentRuleForLastPair :: (DPO m, EpiPairs m, Eq (Obj m)) => Bool -> Bool -> Bool -> Production m -> Production m -> Production m
maxConcurrentRuleForLastPair dep nacInj isInjective c n = concurrentRuleForPair isInjective c n (last selectedPairs)
  where
    selectedPairs = case dep of
                      OnlyDependency -> dependencies
                      _ -> allPairs
    allPairs = pairs isInjective c n
    dependencies = depPairs nacInj isInjective c n

--concurrentRuleForPair :: (DPO m, EpiPairs m, Eq (Obj m)) => Bool -> Production m -> Production m -> (m, m) -> Production m
concurrentRuleForPair inj c n pair = production l r (dmc ++ lp)
  where
    pocC = poc (fst pair) (right c)
    pocN = poc (snd pair) (left n)
    poC = po (fst pocC) (left c)
    poN = po (fst pocN) (right n)
    pb = injectivePullback (snd pocC) (snd pocN)
    l = compose (fst pb) (snd poC)
    r = compose (snd pb) (snd poN)
    dmc = concatMap (downwardShift inj (fst poC)) (nacs c)
    inverseP = production (snd pocC) (snd poC) []
    den = concatMap (downwardShift inj (snd pair)) (nacs n)
    lp = concatMap (shiftLeftNac inj inverseP) den
